### P1 C++编程简介

- 演化

  > C++98 1.0
  >
  > C++11 2.0

- 使用

  > C++标准库
  >
  > C++ PRIMER
  >
  > C++ program language
  >
  > Effective C++
  >
  > the C++ STANDARD LIBRARY
  >
  > STL 源码剖析

### P2 头文件和类的声明

- 代码基本形式

  > 1. 标准库 <>  自己的库 "xxx.h" （可以把h去掉 但如果是c，去掉h需要前面加c）
  > 2. 

### P3 构造函数

- 初始化

  > ```c++
  > complex(double r=0,double i=0):re(r),im(i){}  //先初始化再赋值 效率高
  > ```
  >
  > 1. 不带指针的类一般不用析构函数
  > 2. 重载（常常在构造函数）：已有构造函数有默认函数，不能再写一个空参构造函数，会冲突

- 内联函数

  > 1. 内联函数在编译时会把函数代码副本放置在每个调用函数的地方，对内联函数修改时需要重新编译；
  > 2. 内联函数前面放置inline，已定义函数多于一行时会忽略inline限定符；
  > 3. 类定义的函数都是内联函数，不管有没有使用inline说明符

### P4 参数传递与返回值



### P5 操作符重载与临时对象

- 操作符重载1--成员函数`    -----this`

- 操作符重载2-非成员函数`----无this`

  > 1. inline内联函数  一般少于10行
  > 2. 返回值是否引用：返回的是否是局部变量（临时对象）
  > 3. 传入一般用引用，速度更快，如果担心会被改变，加上const

### P6 复习Complex类的实现过程

- 过程注意点

  > 1. 构造函数的初始化:re(),im(){}
  > 2. 函数需不需要加const，如(double real() const{return re;})
  > 3. 参数传递：要不要加引用以及const
  > 4. 返回：value还是引用

### P7 三大函数：拷贝构造 拷贝复制 析构

- Big Three

  > 1. 拷贝构造函数：
  >
  >    inline String::String()

### P8 堆 栈与内存管理

- stack栈

- heap堆 

  > 1. 内存泄露：指针离开相应的作用域后指针就被销毁了，但是指针指向的空间却仍然存在，所以也没有机会销毁这一片空间->造成泄露

> 1. new: 三步：operate new -> maloc,强制类型转换，构造函数
> 2. delete:两步：析构（动态分配空间），free（string本身的指针 ）
> 3. array delete即delete[]：对于有指针内容，指针本身空间均会被删除，但是指向的空间只会被析构一次，其余空间会被泄露

### P9 复习String类的实现过程

- inline

  > 1. 构造函数析构函数尽量用inline内联，只是建议编译器，并不一定做成内联；
  >
  > 2. =重载：注意判断是否同源，同时注意返回值（同一行连续使用符号）
  >
  >    

### P10 类模板 函数模板

> 1. static：静态变量/函数
>
> 2. 模板：template<typename T> class complex{};类模板
>
>    函数模板：template <class T> inline const T& min(const T& a,const T& b){}--->实现算法
>
> 3. namespace：
>
>    using namespace std;  使用命名空间
>
>    using std::cout;  使用声明
>
>    std::cin<<...;

### P11 组合与继承

- Composition复合 has-a

- 委托

  > 1. 只提供接口
  > 2. copy on write

- 继承 is-a

  > 1. xxx :public struct xx{}
  > 2. 构造由内而外，先调用父类，再执行自己
  > 3. 析构由外而内，先执行自己，再调用父类析构函数
  > 4. 

### P12 虚函数与多态

- 虚函数

  > 1. Template Method
  > 2. 非虚函数：不可以重新定义
  > 3. 虚函数 可以重新定义，但已经有默认定义
  > 4. 纯虚函数 必须重新定义
  > 5. 继承搭配虚函数样例

- 委托和继承

  > 1. 设计模式

### P13 委托相关设计



### P14 导读



## 整理

#### [网站1](https://codeleading.com/article/40313757266/)

- vector扩容原理

  > 1. 新增元素：Vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素；
  > 2. 对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了 ；
  > 3. 不同的编译器实现的扩容方式不一样，VS2015中以1.5倍扩容，GCC以2倍扩容。

- c++类型安全

  > 1. c++远比C更有类型安全性
  > 2. new返回的指针类型严格与对象匹配，而不是malloc返回的void*空类型指针
  > 3. c++提供了dynamic_cast关键字，使得转换过程更加安全
  > 4. 引入const关键字代替#define constants，有类型和作用域，#define constants是简单文本替换；

- C++中四种类型转换方式

  > 1. static_cast:静态类型转换，类似于c的强制类型转换。包括：基本的数据类型转换，int到float等
  > 2. const_cast:去掉类型的const或volatile属性
  > 3. dynamic_cast:有条件转换，动态类型转换，运行时检查类型安全（转换失败返回NULL） 通常用于基类和子类之间的转换
  > 4. reinterpret_cast:仅重新解释类型，但没有进行二进制的转换，可以进行不同类型的指针转换 该转换较危险，很少使用，慎用

- c++11的新特性

  > 1. auto : auto可以根据上下文推测变量类型 auto声明的变量必须要初始化.auto实际上实在编译时对变量进行了类型推导，所以不会对程序的运行效率造成不良影响
  > 2. nullptr:替换NULL，避免NULL可能导致的问题 NULL在C++中代表着0，而nullptr在任何时候都代表空指针。
  > 3. 基于范围的for循环:
  > 4. 虚函数的override和final指示符:
  >    1. override，表示函数应当重写基类中的虚函数
  >    2. final，表示派生类不应当重写这个虚函数
  > 5. 智能指针：为防止内存泄露等问题，用一个对象来管理野指针，使得在该对象构造时获得该指针管理权，析构时自动释放。包含在头文件<memory>中
  > 6. STL
  >    1. unordered_map	采用HASH MAP实现(map内部实现了一个红黑树,故查找时间复杂度为O(logn), unordered_map通过哈希映射实现查找复杂度为O(1));如果没有顺序遍历需求采用unordered_map通常更优
  >    2. unordered_set	采用HASH MAP实现(set采用红黑树实现)
  >    3. array	具有固定大小的数组。支持快速随机访问。不能添加或删除元素。array除了有传统数组支持随机访问、效率高、存储大小固定等特点外，还支持迭代器访问、获取容量、获得原始指针等高级功能
  >    4. forward_list	单向链表。forward_list和list的区别在于前者是单向链表，它的迭代器是前向有效的；后者是双向链表，在内部存在两个链接，它的迭代器是双向有效的。

- malloc/free 和new/delete

  > 1. 相同点：都可用于申请动态内存和释放内存
  > 2. 区别：malloc只分配指定大小的堆内存空间，而new可以根据对象类型分配合适的堆内存空间。free释放对应的堆内存空间，delete,先执行对象的析构函数，在释放对象所占空间。malloc分配时的大小是人为计算的，返回类型是void*,使用时需要类型转换，new在分配时，编译器能够根据对象类型自动计算出大小，返回类型是指向对象类型的指针。new调用构造函数构造对象，而malloc不能；delete将调用析构函数析构对象，而free不能

- 程序的内存分配

  > - 栈区：由编译器自动分配与释放，存放为运行时函数分配的局部变量、函数参数、返回数据、返回地址等
  > - 堆区：一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收
  > - 全局区（静态区static）：存放全局变量、静态数据、常量。程序结束后由系统释放
  > - 常量区（文字常量区）：存放常量字符串，程序结束后有系统释放
  > - 代码区：存放函数体（类成员函数和全局区）的二进制代码

- 内存分配方式

  > - 从静态存储区分配：内存在程序编译的时候已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。
  > - 在栈上创建：在执行函数时，函数内局部变量的存储单元可以在栈上创建，函数执行结束时，这些内存单元会自动被释放。栈内存分配运算内置于处理器的指令集，效率高，但是分配的内存容量有限
  > - 从堆上分配：程序在运行的时候使用malloc或者new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。如果在堆上分配了空间，既有责任回收它，否则运行的程序会出现内存泄漏，频繁的分配和释放不同大小的堆空间将会产生内存碎片

- ###### C++类中数据成员初始化顺序

  > 1.成员变量在使用初始化列表初始化时，与构造函数中初始化成员列表的顺序无关，只与定义成员变量的顺序有关。
  >
  > 2.如果不使用初始化列表初始化，在构造函数内初始化时，此时与成员变量在构造函数中的位置有关。
  >
  > 3.类中const成员常量必须在构造函数初始化列表中初始化。
  >
  > 4.类中static成员变量，只能在类内外初始化(同一类的所有实例共享静态成员变量)。
  >
  > 初始化顺序：
  >
  > ​	1） 基类的静态变量或全局变量
  >
  > ​	2） 派生类的静态变量或全局变量
  >
  > ​	3） 基类的成员变量
  >
  > ​	4） 派生类的成员变量

- 虚函数的实现

  > - 一个含有虚函数（无论是其本身的，还是继承而来的）的类都至少有一个与之对应的虚函数表，其中存放着该类所有的虚函数对应的函数指针
  > - 虚函数构造过程：
  >   - 先拷贝父类的虚函数表
  >   - 替换已重写的虚函数指针
  >   - 增加自己再定义的虚函数指针

#### 类和对象的多态

- 多态出现

  > 通过virtual关键字对多态进行支持，将需要表现多态的父类的函数声明为虚函数，在子类中重写该虚函数
  >
  > 成立的条件：
  >
  > ​	继承、虚函数重写、父类指针指向子类对象（子类继承）
  >
  > 实现原理：
  >
  > ​	虚函数表和vptr指针
  >
  > **任何类若是有虚函数就会比比正常的类大一点，所有有 virtual 的类的对象里面最头上会自动加上一个隐藏的，不让我知道的指针，它指向一张表，这张表叫做 vtable，vtable 里是所有 virtual 函数的地址。**

- 分类

  > 1. 静态多态（编译时多态）：
  >    1. 函数重载 运算符 模板具现化
  > 2. 动态多态（运行时多态）：
  >    1. 派生类和虚函数
  > 3. 优缺点
  >    1. 运行时多态
  >       1. OO 设计中重要的特性，对客观世界直觉认识。
  >       2. 能够处理同一个继承体系下的异质类集合。
  >       3. 运行期间进行虚函数绑定，提高了程序运行开销。
  >       4. 庞大的类继承层次，对接口的修改易影响类继承层次。
  >       5. 由于虚函数在运行期在确定，所以编译器无法对虚函数进行优化。
  >       6. 虚表指针增大了对象体积，类也多了一张虚函数表，当然，这是理所应当值得付出的资源消耗，列为缺点有点勉强
  >    2. 编译时多态
  >       1. 它带来了泛型编程的概念，使得 C++ 拥有泛型编程与 STL 这样的强大武器。
  >       2. 在编译器完成多态，提高运行期效率。
  >       3. 具有很强的适配性与松耦合性，对于特殊类型可由模板偏特化、全特化来处理。
  >       4. 程序可读性降低，代码调试带来困难。
  >       5. 无法实现模板的分离编译，当工程很大时，编译时间不可小觑。
  >       6. 无法处理异质对象集合。

#### 标准输入输出

- 对象

  > 1. 为了处理输入，可以使用一个名为 cin 的 istream 类型的对象，这个对象也被称为标准输入。为了处理输出，可以使用一个名为 cout 的 ostream 类型的对象，这个对象也被称为标准输出
  > 2. 另外标准库 IO 库还定义了两个 ostream 类型的对象，一个是 cerr，用于输出警告和错误信息，这个对象也被称为标准错误，另一个是 clog，用于输出程序运行时的一般性信息

- 文件IO

  > 1. ifstream: 读
  >    1. ifstream fin("./xx.txt");
  >    2. while(!fin.eof())
  >           {
  >               fin >> data[i];  // 按空格读取
  >               i++;
  >           }
  >    3. getline(fin,name);  //按行读取

- 总体

  > ios:
  >
  > ​	-- istream
  >
  > ​		-- ifstream
  >
  > ​		-- iostream	-- fstream
  >
  > ​	-- ostream
  >
  > ​		-- ofstream
  >
  > ​		-- iostream  -- fstream

- 细化

  > 格式化输出 iomanip

##### 模板

- 函数模板格式

  > ```c++
  > template <class 形参名，class 形参名，......> 返回类型 函数名(参数列表)
  > {
  >     函数体
  > }
  > ```

- 类模板通式

  > ```c++
  > template<class  形参名，class 形参名，…>   class 类名
  > { ... };
  > ```
  >
  > ```c++
  > //在类模板外部定义成员函数
  > template<模板形参列表> 函数返回类型 类名<模板形参名>::函数名(参数列表){函数体}，
  > template<class T1,class T2> void A<T1,T2>::h(){}  
  > ```
  >
  > 

#### 笔记

- 头文件

  > 一般一个 C++ 的老的带 “.h” 扩展名的库文件，比如 iostream.h，在新标准后的标准库中都有一个不带 “.h” 扩展名的相对应，区别除了后者的好多改进之外，还有一点就是后者的东东都塞进了 “std” 名字空间中。但唯独 string 特别。 
  > 问题在于 C++ 要兼容 C 的标准库，而 C 的标准库里碰巧也已经有一个名字叫做 “string.h” 的头文件，包含一些常用的 C 字符串处理函数，比如strcmp。这个头文件跟 C++ 的 string 类半点关系也没有，所以 <string> 并非 < string.h > 的 “升级版本”，他们是毫无关系的两个头文件。  
  > 要达到目的，比如同时：  
  > \#include  <string.h>  
  > \#include  <string>  
  > using  namespace  std;  
  > 或者  
  > \#include  <cstring>  
  > \#include  <string>  

### 设计模式(23种)

#### 设计模式概述

- 由来

  > 1. 描述：前提条件、目标问题、解决问题，并给出从用户需求分析到建筑环境结构设计直至经典实例的过程模型
  > 2. 设计模式主要是为了解决某类重复出现的问题而出现的一套成功或有效的解决方案
  > 3. 包含要素
  >    1. 模式名称：通过一两个词来描述模式的问题、解决方案和效果，以便更好地理解模式并方便开发人员之间地交流，绝大多数模式都是根据其功能或模式结构来命名的
  >    2. 问题：描述应该在何时使用模式，包含了设计中存在的问题以及问题存在的原因
  >    3. 解决方案：描述一个设计模式的组成成分，以及这些组成成分之间的相互关系，各自的职责和协作方式，通常解决方案通过UML类图和核心代码来进行描述
  >    4. 效果：描述了模式的优缺点以及在使用模式时应权衡的问题
  > 4. UML：Unified Modeling Language，统一建模语言，是一种为面向对象系统的产品进行说明、可视化和编制文档的一种标准语言，是非专利的第三代建模和规约语言

- 设计模式作用和分类

  > 1. 作用：是一套被反复使用、多数人知晓的，经过分类便目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性
  >
  > | **类型**   | **种类**                                                     |
  > | ---------- | ------------------------------------------------------------ |
  > | **创建型** | 单例模式，简单工厂模式，抽象工厂模式，工厂方法模式，原型模式，建造者模式 |
  > | **结构型** | 适配器模式，桥接模式，组合模式，装饰模式，外观模式，享元模式，代理模式 |
  > | **行为型** | 职责链模式，命令模式，解释器模式，迭代器模式，中介者模式，备忘录模式，观察者模式，状态模式，策略模式，模板方法模式，访问者模式 |

- 优点

  > 1. 融合了众多专家的经验，以一种标准的形式供广大开发人员使用，通俗的设计词汇和通用的语言方便开发人员交流和学习
  > 2. 使人们可以更简单方便地复用成功的设计，使新开发者更容易理解设计思路
  > 3. 使设计方案更加灵活、易于修改
  > 4. 提高软件系统的开发效率和软件质量，节约开发成本
  > 5. 有助于初学者深入理解面向对象思想

#### UML类图介绍

- UML介绍：

  > 在开发阶段，说明、可视化、构建和书写一个面向对象软件的开发方法；

- 常用关系

  > 泛化、实现、关联、聚合、组合、依赖

- UML模型结构

  > 1. 视图：从不同角度来表示待建模系统，视图由许多图形组成的抽象集合；一个系统模型可能有多个视图，每个视图从特定角度来描述系统的特征，比如用户视图、结构视图、行为视图、实现视图。
  > 2. 图
  > 3. 模型元素
  > 4. 通用机制

#### 面向对象设计原则

#### 简单工厂模式

#### 工厂方法模式

#### 抽象工厂模式

### UE4地图

#### 工程形式(Learn选项卡)

- 安装使用

  > 1. 下载并创建项目
  > 2. 安装地址中找到.uproject，双击打开，创建自己的类：文件--新建C++类--无父类--创建类；自动打开VS后环境下载完成
  > 3. 将Airsim/Unreal/Plugins文件夹复制到工程下(.uproject同级)，右击修改.uproject，增加AdditionalDependencies和Plugins
  > 4. 右击.uproject选择Generate Visual Studio project files，双击打开.sln文件，设置编译选择为DebugGame Editor和Win64，设为启动项目
  > 5. F5调试打开，在 世界场景设置中选择 游戏覆盖模式为 `AirSimGameMode`，项目设置--默认游戏模式设为``AirsimGameMode`,保存。

- 再次使用

  > 打开.sln文件，调试运行
  >
  > 直接Launch或者双击Editor可能没有加载airsim插件

#### 资源形式(Unreal Marketplace选项卡)

- 安装使用

  > 1. 新建Unreal工程，启动`Launch Unreal Engine 4.25`,新建项目类型：游戏--空模板--默认配置--修改位置和英文命名，新建完成
  > 2. 加载资源，在Marketplace搜索资源，选择`Add To Project`，选择新建项目名称，下载完成以后会在UE4中出现文件夹；
  > 3. 选择文件夹，过滤器选择关卡(一般选择Demo开头的)，双击使用，在项目设置中修改编辑器开始地图和游戏默认地图；
  > 4. 创建自己的类：文件--新建C++类--无父类--创建类；自动打开VS后，将Airsim/Unreal/Plugins文件夹复制到工程下(.uproject同级)，右击修改.uproject，增加AdditionalDependencies和Plugins，关闭VS和UE4
  > 5. 右击.uproject选择Generate Visual Studio project files，双击打开.sln文件，设置编译选择为DebugGame Editor和Win64，设为启动项目
  > 6. F5调试打开，在 世界场景设置中选择 游戏覆盖模式为 `AirSimGameMode`，项目设置--默认游戏模式设为``AirsimGameMode`,保存。

- 再次使用

  > 打开.sln文件，调试运行
  >
  > 直接Launch或者双击Editor可能没有加载airsim插件

