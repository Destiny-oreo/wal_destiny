#### 钉钉

- 一面（人事平台开发 To B 扩展和定制）

  > 1. 虚函数表？
  > 2. select poll epoll？
  > 3. 线程和进程？
  > 4. 并发太多线程导致什么问题？
  > 5. 数据结构——跳表是什么？（链表的二分查找）
  > 6. 链表有环怎么检测？
  > 7. 二叉树有多少种遍历方式？
  > 8. 二叉树层次遍历如何实现？
  > 9. 排序算法有多少种？
  > 10. 快速排序和堆排序的区别？
  > 11. 哪些排序算法是不稳定的？（稳定：冒泡 插入 归并）选择 快速 堆
  > 12. 数组中整型数据，取top K最大？时间复杂度是多少？如果K很大呢（堆的结构）
  > 13. 有了解过哪些设计模式？有用过设计模式吗？
  > 14. 学C++过程中有没有了解过什么编程规范？如函数 类的命名规则、异常；
  > 15. 有看过开源代码吗，收获比较大的是什么？
  > 16. 数据库有学过吗？比如索引
  > 17. 微服务、分布式有了解吗

#### 字节

- 一面 3.1 14.00（tiktok gola）

  > 1. 哈希表？unordered_map和map区别？ 底层？查询复杂度？应用场景？
  >
  > 2. core dump是什么 或者叫crash？（数组声明完后直接遍历会不会报错
  >
  >    当程序异常终止或者崩溃时，操作系统会把当时的状态纪录下来，保存在一个文件中，就是core dump，用来再现程序出错时的情景；core文件可以使用gdb -c core来查看
  >
  > 3. 如果程序崩了，你应该怎么做？程序很多且不是你写的，不知道在哪里debug怎么办，有没有在服务器上写过
  >
  > 4. 协程是什么？有用过吗？为什么要有协程？
  >
  >    协程又称微线程，不需要进行操作系统内核上的上下文切换，协程的切换由开发人员决定，切换开销大大减少；协程不需要考虑安全问题，因为处于线程内部，自身就会同步；
  >
  >    总结：无需系统内核的上下文切换，减少开销；无需原子操作锁定以及同步的开销，不用担心安全问题；单线程就可以实现高并发，适用于高并发
  >
  > 5. 进程和线程？线程之间的通信如何实现？如何确保线程安全？
  >
  >    互斥锁、条件变量、读写锁、信号量
  >
  > 6. HTTPS？状态码12345，501？
  >
  >    100：继续请求状态；200：请求成功；301：永久移动，302：临时移动；400：客户端请求语法错误；401：请求的语法错误，无法理解；403：理解请求，拒绝执行；501：服务器不支持请求功能，无法完成；502：服务器作为网管或者代理，从远程服务器获得了无效的响应；
  >
  > 7. get post put这些？表单使用什么？可以使用get吗？url慢慢拼的缺点？
  >
  >    [get](https://github.com/febobo/web-interview/issues/145)请求一个资源的表示形式，只用于获取资源，post将实体提交上去（比如get在回退时没有影响，post会再提交一次，get请求会被缓存，post默认不会，get参数被保留，且有长度限制，不安全）
  >
  > 8. HTTPS语言有了解吗
  >
  > 9. LRU（花了15分钟左右）
  >
  > 10. 如何确保线程安全，如LRU的put？
  >
  > 11. C++互斥量这些了解过吗，mutex原理是什么？
  >
  >     [博客](https://www.cnblogs.com/long5683/p/12997011.html)
  >
  > 12. CAS了解过吗？（阅读C++并发编程）
  >
  >     - [对比交换原理](https://www.cnblogs.com/dengzz/p/5686866.html)，将内存上一个值和给定的值进行比较，如果相同修改为一个新的值，原子操作
  >     - Atomic[原子操作类](https://blog.csdn.net/qq_34999565/article/details/114483245)；compare_and_swap，包含compare_swap_weak和compare_swap_strong，检查期待的值和新的数值，如果一直替换为新的数值，如果不一致，将变量的值和期待的值交换

- 面经 [1](https://www.nowcoder.com/discuss/408614?type=post&order=recall&pos=&page=0&ncTraceId=&channel=-1&source_id=search_post_nctrack&gio_id=D5466B331AEE14A29E17E1E0D94C09DC-1645709526811) [2](https://www.nowcoder.com/discuss/593655?type=post&order=recall&pos=&page=2&ncTraceId=&channel=-1&source_id=search_post_nctrack&gio_id=D5466B331AEE14A29E17E1E0D94C09DC-1645709526811) [3](https://www.nowcoder.com/discuss/402106?type=post&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_post_nctrack&gio_id=D5466B331AEE14A29E17E1E0D94C09DC-1645709526811) [4](https://www.nowcoder.com/discuss/393973)

  > 1. TCP和UDP区别
  >
  >    TCP是面向连接的传输协议，在传输数据前需要确保稳定可靠的连接，连接过程经过三次握手（首先主机向服务器发送连接请求，其中包括自己的序列号，服务器收到以后返回一个ack，ack的值是序列号+1，同时带上自己的序列号，最后主机收到ack以后，会也发送一个ack报文，值是序列号+1）
  >
  >    UDP是一个非连接的传输协议，想传输时直接将数据扔到网络上，只需要给数据加一个UDP头标识，由于不建立连接，可以发送广播，就是直接和多个其他主机通信，但是具有不可靠性，适用于实时性高的场所，如电话会议还有视频通话之类的
  >
  > 2. 输入URL以后的[流程](https://zhuanlan.zhihu.com/p/133906695)
  >
  >    1. 输入域名，进行匹配，然后域名解析，获得IP地址
  >    2. 建立TCP连接，发送http请求
  >    3. 服务器收到以后进行永久重定向的相应（一个页面多个域名），浏览器会自动跳转到新URL
  >    4. 服务器会解析http请求，作为request对象进行处理
  >    5. 返回http响应（状态行 响应头 响应体）
  >    6. 浏览器显示html，中间会异步加载嵌在里面的资源
  >
  > 3. C++内存分布  malloc细节
  >
  >    1. 栈区：编译器自动分配的内存，如函数参数值、局部变量
  >
  >    2. 堆区：程序员分配的内存，如new出来的内存
  >
  >       ~~自由存储区：由malloc分配的内存，free来结束~~
  >
  >    3. 程序代码区：存放函数体的二进制代码
  >
  >    4. 全局/静态存储区：存放的是全局变量和静态变量
  >
  >    5. 常量存储区：存放常量值，不允许被修改
  >
  >    6. void* malloc(int size)，未确定类型的指针，可以强制转换为任何其他类型的指针，new返回的是特定类型的指针，包含自动计算分配类型大小，而malloc只能手动计算，一般sizeof
  >
  >    7. malloc只管内存分配，无法初始化，而new一般是构造函数，可以初始化
  >
  > 4. 构造函数和析构函数可否为虚函数  可否调用虚函数
  >
  >    1. 构造不能为虚函数，因为虚函数的类有虚表，类的每个对象都有一个虚表指针，是在构造的时候进行初始化，而如果构造函数为虚函数，构造的时候就要查找虚表，此时虚表指针都没有初始化
  >    2. 析构一般为虚函数，除非不被继承，可以不被设为虚函数，且默认的析构函数就不是虚函数，因为虚函数类有一个虚表以及虚表指针，如果这个类不被继承，那么就会浪费很多空间，所以默认的不是虚函数，相反，如果被继承，虚函数一定要设为虚函数，这样用基类指针构造子类对象的时候，析构的时候才能先析构子类，再析构基类，否则会内存泄露
  >    3. 语法上没有问题，但是效果上没法达到预定目标，因为派生类对象构造期间进入基类的构造函数时，对象类型就变成了基类类型，调用的虚函数就是基类的虚函数，同样进入基类虚构函数时类型也是基类类型，达不到多态的效果
  >
  > 5. sizeof [struct](https://blog.csdn.net/drdairen/article/details/54316779)和union  内存对齐
  >
  >    1. 关键字，判断变量和数据类型的大小，返回的是字节数
  >    2. 结构体和联合都可以存放多个不同的数据类型，但同一时刻，联合内只有一个成员被选中，而结构体的所有成员都存在
  >    3. 结构体的不同成员赋值互相不影响，联合对一个成员赋值时，其他成员相当于进行了重写
  >    4. 内存对齐：结构体中每一个成员都必须分配最大变量长度的空间，虽然后边一部分用不到，但是下一个变量的起始地址需要后移，而联合是以变量的最大长度对齐，数组等元素的最大值作为最后取得值，然后再对齐；——>为了机器进行检索，对齐以后性能上升，以空间换时间，而且也有一部分平台的原因，一些平台只能在特定地址上读取数据
  >
  > 6. 进程的通信方式：
  >
  >    1. 管道：匿名管道（父子进程通信）、命名管道（无关进程的通信）：将一个进程的输出作为另一个进程的输入，通信是单向的，缺点是效率不高，因为这个进程的输出没有被取出来之前是不能结束的，优点是实现简单
  >    2. 消息队列：类似于缓存，将数据放到消息队列中就可以直接退出，另一个进程想要的时候再去取，缺点是当数据比较大的时候开销很大
  >    3. 共享内存：不需要拷贝，各取出来一部分虚拟内存空间，对应到同一块物理内存上，实现独立内存同时又有共享内存
  >    4. 信号量：实现进程之间的同步和互斥，相当于计数器，为1的时候可以进入，然后--，为0不进入
  >    5. socket：实现不同主机上的进程进行通信
  >
  > 7. 数据库的四大特性（事物）
  >
  >    1. 原子性
  >    2. 隔离性
  >    3. 持久性
  >    4. 一致性
  >
  > 8. 多态如何实现（派生类对象可以通过基类指针指向，通过基类指针调用派生类的虚函数）
  >
  >    1. 编译时多态：重载（参数个数不同或类型不同），在编译时就通过把函数名添加上不同参数区分
  >    2. 运行时多态：通过虚函数实现，也就是重写，虚函数允许子类重写基类的成员函数，只要前面加上virtual，使 用时通过基类指针指向子类的对象即可
  >
  >    虚表就是一个指针数组，里面装的都是虚函数的地址值，每个元素对应一个虚函数的函数指针
  >
  > 9. **死锁？四个条件**
  >
  >    死锁是指多个进程在执行的过程中，由于资源的竞争或者通信问题，导致一直在互相等待，如果没有外力作用，会一直阻塞下去的现象就是死锁
  >
  >    互斥条件（资源只由一个进程占用）、不可剥夺条件（未使用完不能被剥夺，只能自己释放）、请求和保持条件（已经至少持有一个医院，又提出了新的资源请求）、循环等待条件（存在一个进程集合，每一个进程都在等待其他进程释放资源）
  >
  > 10. [类的内存分布](https://www.cnblogs.com/jerry19880126/p/3616999.html)
  >
  >     1. 类的成员函数不占内存空间，继承的话内存中先是父类成员变量然后子类变量
  >     2. 如果基类有虚函数的话，内存一开始是虚表指针，然后成员变量，接下来是虚表，然后是虚函数
  >     3. 子类虚表指针继承父类，如果只是重写，虚表和父类一样，如果新声明虚函数，虚表变化，新增子类虚函数地址，虚表指针还是一直指向自己的虚表（如果重写，有新虚函数地址，如果没有，指向父类虚函数）
  >
  > 11. 智能指针，内存泄露[如何检测](https://blog.csdn.net/xiaoshuoladashou/article/details/45541257)
  >
  >     1. unique_ptr  [shared_ptr](https://neo00.top/archives/c11%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98)  weak_ptr
  >     2. 在程序中纪录内存申请和内存释放，最后比对一下是否匹配；具体实现比如在程序中重载new operator 和delete operater，或者visual leak detector--VLD
  >     3. 内存泄露：new忘记delete、数组的越界、野指针现象即内存释放了指针却没有置空、内存没有初始化就进行引用、内存没有分配成功就使用等等
  >     4. 内存碎片：内部碎片：分配的地址没有完全使用；外部碎片：一些未分配连续内存区域太小，不能满足任何进程的内存分配请求——解决：基于页面的管理方式，平均分割内存
  >
  > 12. [消息队列](https://developer.aliyun.com/article/745876)（RabbitMQ）
  >
  >     双向 异步
  >
  >     四个[应用场景](https://cloud.tencent.com/developer/article/1006035)：异步处理、应用耦合、限流削峰、消息驱动的系统
  >
  > 13. [树](https://blog.csdn.net/wanderlustLee/article/details/81297253)
  >
  >     - 二叉搜索树：左子树所有节点比当前节点小，右子树所有节点比当前节点大
  >     - AVL树：平衡二叉搜索树，自平衡，左右子树高度相差小于等于1，Ologn，查找时需要多次磁盘IO（每一层放在一页数据里），效率低
  >     - B树：子节点一般可以有几百上千个，比如m阶的子树，最多有m个孩子和m-1个关键字，大大降低了高度，查找不稳定，内部节点找到就很快，叶子节点就很慢，遍历很麻烦
  >     - B+树：所有数据都在叶子节点，中间节点只起到索引作用，叶子节点从小到大有指针相接，内部节点变少，磁盘加载次数减少，用于文件系统特别是数据库系统
  >     - 红黑树：特殊的平衡二叉树，但不属于AVL，因为左右子树高度不满于小于等于1，但是是解决了AVL自平衡开销大的缺点，查找性能几乎和AVL相同，但是插入和删除上省去了大量平衡度计算，任何不平衡都可以在三次旋转内解决，广泛用于C++ STL比如map和set
  >
  > 14. 多进程和多线程
  >
  >     - 线程是进程子集，一个进程可以包含多个线程
  >     - 进程是资源分配的最小单位，线程是CPU调度的最小单位
  >     - 进程之间的数据是分开的，需要进程通信才可以共享数据，同步简单，而多线程是共享进程的资源，同步复杂
  >     - 进程的切换开销大，设计到资源的分配和回收，线程切换的开销比较小
  >
  > 15. [epoll](https://www.jianshu.com/p/4a36cf56727a)
  >
  >     - IO模式主要有阻塞IO  非阻塞IO  **多路复用IO**  信号驱动IO  异步IO
  >     - epoll是select和poll的增强版，都是用于多连接数的情况，只不过select和poll在监听多个文件描述符时，一旦有一个就绪，就是有数据时，会遍历所有文件描述符来获取数据，而epoll是通过epoll_ctl来注册一个文件描述符，一旦某个就绪，调用回调函数来获取值，不会随着连接数的增加而下降
  >     - [总结](https://m.nowcoder.com/tutorial/10018/8200e3451fe542fbb42779ef6c67db6b)：select缺点：每次都需要把文件描述符从用户态拷贝到内核态，然后就绪后需要遍历所有文件描述符，大小限制为1024
  >     - poll更改了select的文件描述符的描述方式，没有个数限制，但是个数增加效率下降
  >     - epoll使用一个文件描述符管理多个描述符，只讲就绪的放入核心态，不需要多次拷贝，然后不需要遍历所有，只需要就绪的描述符调用回调函数即可
  >
  > 16. C++11[新特性](https://cloud.tencent.com/developer/article/1745592)
  >
  >     - 新增的基于范围的for循环  列表初始化:a(a),...
  >     - 自动类型转换auto nullptr decltype(传入变量 相当于获得变量的类型 后面可以定义新的变量)
  >     - lambda表达式，auto func = [& = ] (int i)->int{i+4} [] (const string& s1,const string& s2)->bool {return s1.size()>s2.size();}
  >     - 新增三个智能指针：unique_ptr shared_ptr weak_ptr
  >     - 新增了long long
  >     - 关于并发引入了[线程](https://blog.csdn.net/weixin_43956732/article/details/109751075)thread 互斥提mutex 条件变量condition_variable atomic
  >
  > 17. [右值引用](https://zhuanlan.zhihu.com/p/335994370)
  >
  >     - 左值：可以取地址并且有名字的东西就是左值
  >     - [右值](https://www.yhspy.com/2019/08/31/C-%E5%B7%A6%E5%80%BC%E3%80%81%E5%8F%B3%E5%80%BC%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/)：不能取地址的没有名字的东西就是右值（将亡值 和 纯右值）
  >     - 纯右值：运算表达式产生的临时变量、不和对象关联的原始字面量、非引用返回的临时变量、lambda表达式等都是纯右值
  >     - 左值引用（const左值引用可以指向右值）：对左值进行引用的类型  **右值引用**：对右值进行引用的类型 &&，将左值转为右值使用std::move()，右值引用既可能是左值也可能是右值（**移动构造函数**）（拷贝构造函数和赋值运算符的重载）（**将临时对象内已经分配好的内存区域直接“偷”过来使用**）
  >
  > 18. erase和remove
  >
  >     - erase对于vector会导致迭代器失效，且只能传入迭代器进行删除
  >
  >       ```c++
  >       vector<int> num={1,2,3,4,5};
  >       int target = 4;
  >       for(vector<int>::iterator it=num.begin();it!=num.end();){
  >       	if(*it==target){
  >               it = num.erase(it);
  >           }else{
  >               ++it;
  >           }
  >       }
  >       ```
  >
  >     - remove只是把目标数覆盖，比如AAABBBAAA，`auto p=std::remove(vec.begin(),vec.end(),'A')`后，编程BBBBBBAAA，但返回的迭代器指向的是下标为3，即尾部B的下一位，后面的位数就是目标数的数量，vec.size不变，配合erase使用
  >
  > 19. 拥塞控制
  >
  >     - 在两个主机互相通信时，如果发送方迟迟没有接收到接收方消息，就认为丢失，会重发，name如果此时是太多主机在使用信道导致拥塞，那么重发数据包只会加剧拥塞
  >     - 拥塞窗口，一个一个加，指数加，相结合，一开始指数，到达阈值以后一个一个加，这个阈值不是临界值，（指数截断是**慢启动**，线性增长是**拥塞避免**），到达瓶颈后，调整阈值为max的一半，继续发送
  >     - 丢失和拥塞：使用冗余ACK来解决，就是拥塞的话，发送数据后接收不到消息，而丢失3的话，发送1 2 4 5，所以会收到三次收到2，而收不到3，代表丢失3，此时不会把拥塞窗口调为1，而是调为阈值（max的一半）->**快速恢复**
  >
  > 20. volatile
  >
  >     - 类型修饰符，用于修饰变量，用它表明的变量表示可以被编译器未知的因素修改，遇到这个修饰符修饰的变量，编译器不在对这个变量的代码优化；就是每次使用到这个修饰符修饰的变量时，都需要重新从内存读取，而不是直接使用上一次读取的内容
  >
  > 21. [Nginx](https://zhuanlan.zhihu.com/p/34943332)
  >
  > 22. [unordered_map](https://www.cnblogs.com/yimeixiaobai1314/p/14375195.html)
  >
  >     基于哈希表也叫散列表实现，平均插入和查询复杂度是O1，但不稳定，最差情况是On，为了不经过任何比较就找到搜索元素，需要构造一种存储结构，通过哈希映射函数使元素的存储位置和关键码之间能够建立一一映射的关系；散列表内存使用更大，内存效率不是100%，冲突越多，查询次数越多
  >
  >     使用场景：哈希表适用于查询速度快，对单次查询速度不敏感；后者稳定，与插入顺序无关，支持范围查找，对单词查询时间敏感，实时应用等

  

