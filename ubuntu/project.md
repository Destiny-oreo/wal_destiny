# C++服务器

## 框架

#### 概念

- gcc/g++

  ```
  GCC:GNU Compiler Collection(GUN 编译器集合)，可以编译C D++ JAV等语言，gcc是其中的C编译器，g++是C++编译器；gcc 调用了 C compiler，而 g++ 调用了 C++ compiler
  主要区别：
  1.对于.c和.cpp,gcc当做c和cpp文件编译，g++5统一当做cpp文件编译
  2.g++自动链接标准库STL
  3.gcc编译C文件时，可使用的预定义宏是比较少的
  4.编译cpp文件时，会加入一些额外的宏，gcc编译c++文件时，为了能够使用STL需要加参数-lstdc++
  但当程序包含有很多个源文件时，则出现了make工具
  ```

- make

  ```
  批处理工具，通过调用makefile文件中用户指定的命令来进行编译和链接，makefile命令中包含了调用gcc等去编译某些源文件的命令；在一些简单的工程中，可以人工手写makefile，但是当工程非常大的时候，可以通过cmake工具来实现，只需要写Cmakelist.txt来自动生成makefile文件
  ```

- CMake

  ```
  跨平台编译工具，比make更加高级，一般使用IDE自动生成
  ```



#### 开发环境

```
Ubuntu20.04
gcc7 g++7
cmake
```

- 项目路径

  ```C++
  bin				--二进制文件
  build			--中间的文件路径
  cmake			--cmake函数的文件夹
  CMakeLists.txt	--cmake的定义文件
  lib				--库的输出路径
  Makefike
  wal				--源代码
  test			--测试代码路径
  ```

  



#### 日志系统

- 框架

  ```
  Log4J
  Logger(定义日志类别)
  	Formatter(日志格式)
  Appender(日志输出的地方)
  ```

  

#### 协程库封装



#### socket函数库



#### HTTP协议开发



#### 分布协议







## 大并发服务器

#### [框架介绍](https://www.cnblogs.com/secondtonone1/p/7076769.html)

- **C/S结构**：客户端 服务器结构；**B/S结构**：浏览器 服务器结构 http协议

- 最高效的网络I/O模型：epoll

  ```
  1.DAL:队列服务+连接池 解决超过最大并发数
  cache：缓存（将热点数据存至缓存），客户端提交请求以后先从缓存中提取数据，减少响应时间
  	问题：缓存如何更新同步：1.设置缓存的time out，失效以后重新去数据库查询并更新，实时性较     差；2.服务器更新数据时将修改数据投入DAL，实时性较好
  2.缓存换页：当缓存较多时，需要将不活跃缓存数据换出内存，非关系缓存如redis
  ```

- 负载均衡

  ```
  1.由于读操作数量>写操作数量，读写分离，为达到负载均衡，数据库服务器采用replication机制，写操作投递到master数据库，读操作投递到slave数据库
  2.应用服务器的负载均衡通过设计一个任务服务器，监控应用服务器的负载情况，任务服务器主动分配任务时会存在分配不合理的情况（读写操作数量不对等），采用被动被动分配任务，当应用服务器空闲时主动请求分配任务再分配缓存的任务队列。
  3.任务服务器设置备用服务器，多任务服务器之间实现心跳，检测不到心跳直接成为主任务服务器
  ```

- 数据库分区（分库 分表）

  ```
  1.分库：按照逻辑把表分散到不同的数据库，垂直分区，每个库的表不同，功能不同，但是由于各个表很大情况会有关联，所以不常用。
  2.分表：将一个表的不同数据分配到各个数据库，每个数据库的表结构一样，叫做水平分区。
  ```

- 服务器性能杀手

  ```
  数据拷贝	采用缓存的方式解决
  环境切换	多线程还是单线程，单核服务器采用状态机编程效率最高
  内存分配	采用内存池提前分配
  锁竞争
  ```

  

#### 大型网站架构演变过程

- web服务器：http服务器+应用服务器

  ```
  ```

  

### ESP8266

> 





















