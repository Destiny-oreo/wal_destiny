# 题目链接
[leetcode 96](https://leetcode-cn.com/problems/unique-binary-search-trees/)

# 原文
给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

示例:

输入: 3
输出: 5  
解释:  
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:
  
   1         3     3      2      1  
    \       /     /      / \      \  
     3     2     1      1   3      2  
    /     /       \                 \  
   2     1         2                 3  

# 思路
- ### **二叉搜索树**
  将指定的n个数构成标准的二叉搜索树，二叉搜索树的特点使左子树的节点均大于当前节点，右子树的节点均大于当前节点，所以通过找规律可得，当共有n个数时，根节点有n中情况，分别为1-n，所以将n中情况的总和相加即可，当根节点为1时，左子树右0个节点，右子树有n-1个节点，当根节点为2时，左子树有1个节点，右子树有n-2个节点，当根节点为m时，左子树有m-1个节点，右子树有n-m个节点：所以dp(n)=f(1)+f(2)+f(3)+...+f(n)，且对于f(m)来说，其左子树有m-1个节点，且这m-1个节点必须也符合二叉搜索树，共有dp(m-1)中情况，同理右子树有n-m个节点，共有dp(n-m)中情况，即dp(n-(m-1)-1)。62 5

# 代码
- C++ 二叉搜索树
```
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n+2,0);
        dp[0] = 1;
        for(int i=1;i<=n;i++){
            for(int j=0;j<i;j++){
                dp[i] += dp[j]*dp[i-j-1];
            }
        }
        return dp[n];
    }
};
```