# 题目链接
[leetcode 201](https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/)

# 原文
给定范围 [m, n]，其中 0 <= m <= n <= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。  
示例 1:   
输入: [5,7]  
输出: 4  
示例 2:  
输入: [0,1]  
输出: 0  

# 思路
- ### **位运算**
  研究题目意思以后发现，只要范围内的位上存在一个0，则相与以后全是0，所以只有高位相同才能幸存下来，直接研究最高位和最低位之间的关系即可；发现找到两个数从高为开始的相同数，其后的所有位置0即可；找到相同位的方式需要右移，只要当前m和n不相等，说明低位有异，同时右移并记录次数，最后将低位置0的方法是向左再移动相同的次数，导致相同高位归位以及左移的所有低位全是0。85 47

# 代码
- C++ 位运算
```
class Solution {
public:
    int rangeBitwiseAnd(int m, int n) {
        int bits = 0;
        while(m!=n){
            m>>=1;
            n>>=1;
            bits++;
        }
        return n<<bits;
    }
};
```
